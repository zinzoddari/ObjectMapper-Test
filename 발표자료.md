# 1. 발표자 소개
# 2. 왜 발표 하게 되었는지
외부 API를 연동할 때, 여러분은 테스트를 어떻게 하시나요?
저는 주니어 시절, 매번 스프링 애플리케이션을 직접 띄우고 실제로 API를 호출해 보면서 응답을 검증하곤 했습니다.

문제가 생기면
- 설정을 조금 고치고
- 다시 애플리케이션을 띄우고
- 다시 호출해서 확인하고

이 과정을 무한 반복했습니다.

테스트 시간이 길어지고, 작은 실수 하나에도 전체 플로우를 다시 돌려봐야 했습니다.
과연 이 방식이 최선인지 계속 의문이 들었습니다.

그러던 중 RestTemplate·RestClient 같은 HTTP 클라이언트 내부를 들여다보니,
응답 JSON을 DTO로 바꿔주는 핵심이 결국 HttpMessageConverter -> ObjectMapper 구조라는 것을 확인했습니다.

“그렇다면 전체 애플리케이션을 띄우는 대신, **ObjectMapper가 JSON을 제대로 DTO로 변환하는지만 테스트하면 되는 것 아닐까?**”
라는 생각이 자연스럽게 들었습니다.

실제로 회사에서 외부 API의 응답 필드가 하나 추가되면서 역직렬화 예외가 발생해 장애가 난 경험이 있었습니다.
이 문제 역시 ObjectMapper의 동작을 사전에 테스트했더라면 충분히 방지할 수 있었습니다.

즉, 프로덕션 환경이 아니더라도 **외부 API 응답 스키마 변화에 대한 검증을 개발 단계에서 미리 할 수 있다**는 의미입니다.

이 발표는 바로 이 지점에서 출발했습니다.
외부 API 연동 테스트를 굳이 애플리케이션 전체를 띄우고 진행하지 않아도,
핵심 매핑 로직(ObjectMapper)을 단위 수준에서 검증하면 더 빠르고 안정적인 연동이 가능하다는 점을 공유하고 싶었습니다.

# 2. 들어가기 앞서
외부 API 테스트 얘기를 본격적으로 시작하기 전에,
이 발표 내용을 이해하는 데 꼭 필요한 **기본 용어 두 가지**를 먼저 정리하고자 합니다.
- MessageConverter
- ObjectMapper
  이 두 요소를 정확히 알면 스프링에서 JSON이 어떻게 처리되는지 전체 흐름을 쉽게 이해할 수 있습니다.

## 2-1. ObjectMapper란?
ObjectMapper는 Jackson 라이브러리의 핵심 클래스입니다.
JSON을 자바 객체로 바꾸거나(JSON -> Object),
자바 객체를 JSON으로 바꾸는 역할(Object -> JSON)을 담당합니다.

우리가 @RestController로 API를 만들 때도
ObjectMapper를 직접 호출하지 않지만,
스프링 MVC 내부에서 요청과 응답을 변환하는 과정에서 항상 ObjectMapper가 자동으로 사용됩니다.

즉, 스프링 MVC 환경에서 JSON을 다루면 결국 ObjectMapper를 사용하고 있다는 의미입니다.

## 2-2. 스프링 MVC에서 이미 ObjectMapper를 사용하고 있는 구조
요청(Request)과 응답(Response) 모두 다음 흐름을 따릅니다:
- 클라이언트 -> JSON 요청
- 스프링 -> JSON을 Object로 변환
- 컨트롤러 실행
- 리턴 DTO -> JSON으로 다시 변환해 응답

여기서 JSON 변환을 담당하는 계층이 바로 MessageConverter + ObjectMapper 조합입니다.
![Pasted image 20251207113006.png](image%2FPasted%20image%2020251207113006.png)

## 2-3. MessageConverter란 무엇인가?
MessageConverter란, HTTP 메시지(JSON, XML, Plain text 등)를
자바 객체로 변환하거나, 그 반대로 변환하는 스프링 MVC의 표준 인터페이스입니다.

하지만 JSON은 MessageConverter가 직접 파싱하는 것이 아닙니다.

JSON 변환이 필요한 경우:
- MessageConverter가 “JSON을 다뤄야 한다”고 판단
- 내부에서 ObjectMapper를 호출
    - JSON -> Object (역직렬화)
    - Object -> JSON (직렬화)
    - 변환을 수행합니다.

즉,
- MessageConverter = JSON 변환을 담당하는 **중계자**
- ObjectMapper = JSON 변환을 **실제로 수행하는 엔진**
  이라는 관계입니다.

### 이전 글
- ObjectMapper가 무엇인지에 대한 개념 설명을 간단하게 하고자 함.
- 그래야 뒤의 내용을 들을 때에도 자연스럽게 이어지는 내용이 될 것 같음
- 다만, 이 범위가 어디까지 되어야 하는지에 대해서는 아직도 고민 중

# 3. 테스트
테스트에 들어가기 앞서, 기반 코드

## application.yml
```yaml
api:  
  uri: https://jsonplaceholder.typicode.com
```

## Client.java
```java
@Slf4j  
@Component 
public class Client {
  
    private final RestTemplate restTemplate;
    
    public Client(@Value("${api.uri}") final String baseUri, final RestTemplateBuilder restTemplateBuilder) {  
        this.restTemplate = restTemplateBuilder.rootUri(baseUri).build();  
    }
  
    public <T> T get(final String uri, final ParameterizedTypeReference<T> typeReference) {  
  
        log.info("request (GET): {}", uri);  
  
        final ResponseEntity<T> response = restTemplate.exchange(uri, HttpMethod.GET, null, typeReference);  
  
        log.info("response (GET): {}, {}", uri, response);  
  
        return response.getBody();  
    }  
}
```

![Pasted image 20251208000910.png](image%2FPasted%20image%2020251208000910.png)

## 3-1. 기존 애플리케이션 띄워서 테스트
외부 API를 호출할 수 있는 내부 API를 개발

JSON 응답을 받을 수 있는 dummy API를 예시로 듦
- https://dummyjson.com/
## 3-2. 애플리케이션을 직접 띄워 테스트
제가 가장먼저 외부 API 연동을 테스트했던 방식입니다.

외부 API 호출을 담당하는 Client를 호출하는 Service와 Controller를 구현한 뒤,
스프링 애플리케이션을 실제로 실행하여 테스트하는 방식입니다.

스프링읠 띄운 상태에서 로컬 엔드포인트를 호출하고,
그 결과가 정상적으로 처리가 되는지 직접 확인할 수 있습니다.

### ClientService.java
```java
@Service  
@RequiredArgsConstructor  
public class ClientService {  
  
    private final Client client;  
  
    public List<UserResponse> getUsersTest() {  
        return client.get("/users", new ParameterizedTypeReference<>() {});  
    }  
}
```

### ClientController.java
```java
@RestController  
@RequestMapping("/user")  
@RequiredArgsConstructor  
class UserController {  
  
    private final UserService userService;  
  
    @GetMapping("/{id}")  
    public User getUserInfo(@PathVariable final Long id) {  
        return userService.getUserInfo(id);  
    }  
}
```
![Pasted image 20251207165128.png](image%2FPasted%20image%2020251207165128.png)

```curl
curl --location 'http://localhost:8080/test/users'
```
![Pasted image 20251207165359.png](image%2FPasted%20image%2020251207165359.png)

- 장점
    - 실제 운영 환경과 거의 동일하게 검증 가능
        - Spring MVC, Filter, Interceptor, Security 등 운영에 가까운 전체 플로우와 함께 같이 테스트가 가능합니다.
- 단점
    - 테스트용 엔드포인트를 매번 생성
        - 외부 API를 호출하기 위한 코드가 계속 늘어나게 됩니다.
    - 수정할 때마다 애플리케이션 재기동 필요
        - DTO나 Client 설정 변경 등 아주 작은 수정에도 서버를 다시 띄워야 합니다.
        - 반복 작업의 비용이 크고, 빠른 실행 및 검증이 어렵습니다.
    - 문제 원인이 섞여 특정 문제만 확인이 어려움
        - URL 설정, 시큐리티 설정, CORS 필터, 네트워크 이슈 등 여러 요소가 한 번에 섞여 있습니다.
        - 덕분에 테스트하고자 하는 포인트가 흐려질 수 있습니다.
    - 외부 환경 의존
        - 실제 외부 API 서버 상태, 네트워크, VPN, 속도 등에 따라 테스트 영향이 발생합니다.
        - 자동화 테스트에서 돌리기에는 부담이 큽니다.

## 3-3. SpringBootTest 테스트
이번 방법은 제가 Test 코드 작성 법을 배우고나서, 했던 방식입니다.

외부 API 호출 하기 위해 Controller, Service를 따로 만들 필요 없이,
Client를 스프링 Bean으로 등록했다면, @SpringBootTest 환경에서 바로 DI 받아 호출할 수 있습니다.

```java
@SpringBootTest  
class ClientTest {  
  
    @Autowired  
    private Client client;  
  
    @Test  
    @DisplayName("외부 API를 통해 회원 정보를 조회합니다.")  
    void get_users_success() {  
        // given  
        final String uri = "/users";  
  
        // when  
        final List<UserResponse> result = client.get(uri, new ParameterizedTypeReference<>() {  
        });  
  
        // then  
        assertThat(result).isNotEmpty();  
    }  
}
```

- 장점
    - 테스트용 Controller/Service를 만들 필요가 없음
        - Client 빈만 준비되어 있으면 바로 테스트를 수행할 수 있습니다.
    - **애플리케이션 전체 환경에서 실제 동작을 검증 가능**
        - RestTemplate, MessageConverter, ObjectMapper 설정이
        - 프로덕션과 동일한 상태에서 테스트됩니다.
- 단점
    - 테스트 비용이 비쌈
        - SpringBootTest는 애플리케이션 컨텍스트를 전체 띄우기 때문에 실행 시간이 길어집니다.
    - 여러 외부 API 검증하려면 테스트가 불필요하게 무거워짐
        - 단순 JSON -> Object 역직렬화 잘 되는지 확인하기 위해서 매번 전체 애플리케이션을 띄어야 합니다.
    - 외부 환경 영향을 여전히 받음
        - 외부 API 서버 상태나 네트워크 등의 이슈가 테스트 결과에 영향 줄 수 있어서 자동화 테스트 환경에는 적합하지 않습니다.
## 3-4. JsonTest
해당 테스트 방식은, Spring Boot가 실제 사용하는 ObjectMapper 설정을 그대로 로딩하여 JSON <-> Object 간 매핑이 올바르게 이뤄지는지 확인할 수 있습니다.

외부 API 호출하는 것은 아니며, 순수하게 직렬화, 역직렬화 검증에 특화되어 있는 방식입니다.
```java
@JsonTest  
class PostsResponseTest {  
  
    @Autowired  
    private JacksonTester<PostsResponse> jsonTester;  
  
    @Test  
    @DisplayName("json 문자열을 객체로 성공적으로 매핑합니다.")  
    void readValue() throws IOException {  
        //given  
        final String json = """  
                {                    
	                "posts": [
		                {
			                "id": 1,
			                "title": "His mother had always taught him",
			                "body": "His mother had always taught him not to ever think of himself as better than others. He'd tried to live by this motto. He never looked down on those who were less fortunate or who had less money than him. But the stupidity of the group of people he was talking to made him change his mind.",                            
			                "tags": [                                
				                "history",
				                "american",
				                "crime"
							],
							"reactions": {
								"likes": 192,
								"dislikes": 25
							},
							"views": 305,
							"userId": 121
						}
					],
					"total": 251,
					"skip": 0,
					"limit": 30
				}
			""";  
  
        //when  
        final PostsResponse response = jsonTester.parseObject(json);  
  
        //then  
        assertSoftly(it -> {  
            it.assertThat(response.getPosts().get(0).getId()).isEqualTo(1);  
            it.assertThat(response.getPosts().get(0).getTitle()).isEqualTo("His mother had always taught him");  
            it.assertThat(response.getPosts().get(0).getBody()).isNotNull();  
        });  
    }  
}
```

### @SpringBootTest - @JsonTest 차이점
| 항목          | @SpringBootTest             | @JsonTest           |
| ----------- | --------------------------- | ------------------- |
| 애플리케이션 컨텍스트 | 전체                          | Jackson 관련 Bean만 로딩 |
| 외부 API 호출   | 가능                          | 불가능                 |
| 목적          | end-to-end 검증               | ObjectMapper 매핑 검증  |
| 속도          | 느림                          | 빠름                  |
| 테스트 목적      | 외부 API 호출 클라이언트 + 설정 + 네트워크 | JSON <-> Object 매핑  |
- 장점
    - 실제 스프링 애플리케이션에서 사용하는 ObjectMapper 설정 그대로 검증
        - 다양한 설정들이 그대로 적용되어 테스트 가능 (e.g. FAIL_ON_UNKNOWN_PROPERTIES)
    - SpringBootTest 전체를 로드하지 않기 때문에 테스트 속도가 빠름
    - 외부 API 의존 X
    - 독립적이기 때문에, CI/CD 파이프라인에서도 안정적으로 동작
- 단점
    - SpringBoot 환경에 종속적
    - 외부 호출 클라이언트가 Spring의 ObjectMapper 사용하지 않으면 차이 발생

## 3-5. POJO 역직렬화 테스트
스프링 환경을 띄우지 않고,
ObjectMapper만 직접 사용해서 JSON -> Object 매핑이 정상적으로 동작하는지 검증하는 방식입니다.
즉, 순수한 POJO 환경에서 Jackson 기능만 테스트합니다.

각 Client마다 필요한 ObjectMapper 설정을 독립적으로 테스트할 수 있게 되었습니다.

```java
class DummyObjectMapperTest {  
  
    private final ObjectMapper objectMapper;  
  
    public DummyObjectMapperTest() {  
        final DummyObjectMapperProviderHelper helper = new DummyObjectMapperProviderHelper();  
  
        this.objectMapper = helper.getDummyObjetMapper();  
    }  
  
    @Test  
    @DisplayName("json 문자열을 객체로 성공적으로 매핑합니다.")  
    void readValue() throws JsonProcessingException {  
        //given  
        final String json = """  
                {                    
	                "posts": [
		                {
			                "id": 1,
			                "title": "His mother had always taught him",
			                "body": "His mother had always taught him not to ever think of himself as better than others. He'd tried to live by this motto. He never looked down on those who were less fortunate or who had less money than him. But the stupidity of the group of people he was talking to made him change his mind.",                            
			                "tags": [                                
				                "history",
				                "american",
				                "crime"
							],
							"reactions": {
								"likes": 192,
								"dislikes": 25
							},
							"views": 305,
							"userId": 121
						}
					],
					"total": 251,
					"skip": 0,
					"limit": 30
				}
			""";
			
        //when  
        final PostsResponse response = objectMapper.readValue(json, PostsResponse.class);  
  
        //then  
        assertSoftly(it -> {  
            it.assertThat(response.getPosts().get(0).getId()).isEqualTo(1);  
            it.assertThat(response.getPosts().get(0).getTitle()).isEqualTo("His mother had always taught him");  
            it.assertThat(response.getPosts().get(0).getBody()).isNotNull();  
        });  
    }
```

- 장점
    - SpringBoot 의존이 없음
    - 컨텍스트를 띄울 필요가 없기에 테스트 속도가 빠름
    - ObjectMapper만 테스트하기 때문에 테스트 환경이 가볍고 단순
    - 외부 환경에 영향 받지 않음
    - 외부 Client 마다 ObjectMapper가 다르다면 각자 설정 부여해서 테스트 가능함
    - Object 매핑 정확도를 개발 단계에서 즉시 확인 가능
        - 필드 누락이나 타입 불일치 등의 런타임 장애 유발 요소를 빌드 단계에서 바로 발견 가능
- 단점
    - SpringBoot의 실제 ObjectMapper 설정과 다를 수 있음
    - HTTP 호출 로직 테스트는 불가능

# 최종적으로
외부 API 연동 테스트는 크게 두 가지 관점으로 나눠볼 수 있습니다.
- 실제 외부 API와 통신이 제대로 되는지 테스트
- 응답 JSON이 우리 Object로 정확히 매핑되는지 검증하는 테스트

실제 운영 환경과의 통신 자체는 보통 하나의 통합 테스트로만 확인해도 충분하다고 생각합니다.
네트워크, 인증, 타임아웃, Base URI 설정 등이 정상적으로 동작하는지 확인하면 됩니다.

추가로, 외부 API 연동에서 가장 많은 문제가 발생하는 지점은 JSON -> Object 역직렬화가 제대로 되는지 입니다.
응답 스키마 변경이나 필드 추가, 삭제, 타입 불일치 등은 실제 런타임에서 장애를 일으키키 쉬운 영역이기 때문입니다.

그래서 나머지 대부분의 테스트는 ObjectMapper가 해당 JSON을 제대로 매핑할 수 있는지
즉, 역직렬화, 직렬화 검증에 집중하는 것이 효율적이라고 생각됩니다.

# 7. 그 외 테스트할 수 있는 방법 (없는 필드, 스네이크 등)
- 1. 없는 필드가 오더라도 정상적으로 역직렬화 테스트할 수 있는지
```java
@Test  
@DisplayName("존재하지 않는 key의 경우, 예외가 발생합니다.")  
void ignoreKey() {  
    //given  
    final String json = """  
            {
	            "hello": "hi"
			}
		""";  
  
    //when & then  
    assertThatThrownBy(() -> objectMapper.readValue(json, PostsResponse.class))  
            .isInstanceOf(UnrecognizedPropertyException.class);  
}
```
- 2. 직렬화 왕복 테스트
```java
@Test
@DisplayName("객체 <-> JSON 왕복 변환이 깨지지 않는다.")
void roundTrip() throws Exception {
    // given
    PostsResponse original = new PostsResponse(...);

    // when
    String json = objectMapper.writeValueAsString(original);
    PostsResponse restored = objectMapper.readValue(json, PostsResponse.class);

    // then
    assertThat(restored).usingRecursiveComparison()
            .isEqualTo(original);
}
```

## 추가하면 좋을 점
1. 각 테스트마다 한 10개 정도? 테스트 하고 시간 비교한 결과물이 있으면 좋을 것 같음
2. SpringBoot에서 ObjectMapper Bean 등록 시, FAIL_ON_UNKNOWN_PROPERTIES 옵션 비활성화
    - new로 ObjectMapper 만들면 활성화 되는 차이도 녹여내기
# 8. Q&A
# 9. 마무리