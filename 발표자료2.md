# 1. 발표자 소개
...

# 2. 왜 발표하게 되었나요?
🎤
Spring 환경에서 외부 API를 연동할 때,
여러분은 보통 어떤 방식으로 테스트하고 계신가요?

저는 외부 API를 연동하면서
응답 JSON이 DTO로 잘 매핑되는지 확인하는 작업을
자주 하게 되었습니다.

그런데 이 매핑을 확인하기 위해
늘 같은 과정을 반복하고 있었습니다.

DTO를 수정하고,
스프링 애플리케이션을 다시 실행한 뒤,
외부 API를 호출하는 내부 API를 만들어
직접 요청을 보내 확인하는 방식이었습니다.

처음에는 당연하다고 생각했지만,
이 작업이 반복될수록 점점 의문이 들기 시작했습니다.

‘지금 내가 확인하고 싶은 건
외부 API 호출 자체일까,
아니면 이 JSON이 DTO로 잘 매핑되는지일까?’

이 질문을 계기로,
매핑 검증만 따로 더 단순하게 확인할 수는 없을지 고민하게 되었고,
그 과정에서 오늘 이야기할 방법을 정리하게 되었습니다.

# 3. 기존 방식에서 겪은 문제
🎤
예전에는 응답 매핑을 확인하기 위해
외부 API를 호출하는 테스트용 컨트롤러를 만들었습니다.

그리고 항상 같은 과정을 반복했습니다.
DTO 수정 → 서버 재실행 → API 호출 → 결과 확인

이 방식이 왜 반복될 수밖에 없었는지,
실제 흐름을 한 번 같이 따라가 보겠습니다.


🎤
오늘 예제로 사용할 외부 API 응답 값은
다음과 같은 JSON 형식입니다.

![Pasted image 20251215005913.png](image%2FPasted%20image%2020251215005913.png)

```json
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
```

🎤
그리고 이 응답을 매핑하기 위한 자바 객체로
TodoResponse가 준비되어 있습니다.
```java
@Getter  
@NoArgsConstructor(access = AccessLevel.PRIVATE)  
public class TodoResponse {  
  
    private Long userId;  
  
    private Long id;  
  
    private String tilte; // <- 🔥 오타
  
    private Boolean completed;  
}
```
🎤
여기서 보시면,
title 필드에 오타가 있는 상태입니다.
하지만 이 시점에서는 아직 문제를 알 수 없습니다.
---
🎤
이 응답이 실제로 잘 매핑되는지 확인하기 위해,
저는 외부 API 호출을 트리거하는
내부 API를 하나 더 만들었습니다.

![Pasted image 20251215010321.png](image%2FPasted%20image%2020251215010321.png)

🎤
요청 흐름은 대략 이런 형태입니다.
Controller -> Service -> Client -> External API
그리고 응답이 다시 같은 경로로 돌아옵니다.

즉, 응답 매핑 하나를 확인하기 위해
이 전체 흐름을 매번 타고 있었습니다.

---
🎤
그럼, 외부 API 호출 결과가 매핑이 잘 되는지 확인하기 위하여
Spring 애플리케이션을 실행합니다.

![Pasted image 20251214161257.png](image%2FPasted%20image%2020251214161257.png)

🎤
서버가 정상적으로 올라오면,
방금 만든 API를 curl로 호출합니다.

![Pasted image 20251214161438.png](image%2FPasted%20image%2020251214161438.png)
🎤
그런데 이때,
응답으로 **500 에러**가 내려옵니다.
> 위 이미지를 가지고, 오류가 발생하는 GIF?나 이미지 첨부하는게 좋을 듯

🎤
하지만, 응답으로 Status가 500이 내려오게 되면, 필드를 수정하고, 또 재실행해서 재 호출을 하게 됩니다.

```
UnrecognizedPropertyException: Unrecognized field "title"
```
🎤
에러의 원인은 단순했습니다.

JSON에는 title 필드가 있는데,
DTO에는 매핑될 title 필드가 없었습니다.

그래서 ObjectMapper가
“이 필드를 어디에 넣어야 할지 모르겠다”고 실패한 것입니다.

🎤
우리는 다행히 이미 오타 때문에 발생한 오류임을 인지할 수 있었는데요.
그래서 필드명을 수정하고,
```java
public class TodoResponse {  
	...
    private String tilte; // <- 오타
```

🎤
다시 스프링 애플리케이션을 재실행한 뒤,
같은 API를 다시 호출합니다.
![화면 기록 2025-12-14 17.18.32.gif](image%2F%ED%99%94%EB%A9%B4%20%EA%B8%B0%EB%A1%9D%202025-12-14%2017.18.32.gif)
![화면 기록 2025-12-14 17.21.23.gif](image%2F%ED%99%94%EB%A9%B4%20%EA%B8%B0%EB%A1%9D%202025-12-14%2017.21.23.gif)

🎤
이제서야 정상 응답을 확인할 수 있습니다.
---
🎤
이 과정을 정리해보면,
제가 하고 있던 테스트는 항상 이 흐름이었습니다.
```
[DTO 필드 수정]
        ↓
[Spring 애플리케이션 재실행]
        ↓
[API 호출]
        ↓
[응답 매핑 결과 확인]
        ↺ (실패 시 다시 반복)
```
🎤
결국 외부 API 응답이
객체로 잘 매핑되는지 확인하기 위해
매번 같은 과정을 반복하고 있었습니다.

🎤
그러다 문득 이런 생각이 들었습니다.
> "내가 확인하고 싶은 건
> 이 JSON이 DTO로 잘 매핑되는지인데,
> 매번 서버를 띄워야만 할까?”

🎤
그래서
매핑만 따로 검증할 수는 없을지
고민하게 되었습니다.

이를 위해,
먼저 매핑이 이루어지는 지점부터
확인해보겠습니다.

# 4. 원인 해부 : JSON -> DTO 변환의 실제 주체

🎤
앞에서 봤던 매핑 오류를 기준으로,
이제 실제로 어디에서 매핑이 일어나는지를 살펴보겠습니다.
![Pasted image 20251214173317.png](image%2FPasted%20image%2020251214173317.png)

🎤
RestTemplate으로 외부 API를 호출하면
HTTP 통신 자체는 내부 HttpClient가 담당합니다.
이 단계에서는 단순히 JSON 문자열을 받아오는 역할만 합니다.

🎤
중요한 부분은 그 다음입니다.

🎤
RestTemplate은 응답을 그대로 반환하지 않고,
HttpMessageConverter에게 “이 응답을 객체로 바꿔달라”고 위임합니다.

🎤
(실제 코드 첨부해보기)
그리고 JSON 응답의 경우,
이 역할을 담당하는 것이
MappingJackson2HttpMessageConverter입니다.

🎤
(실제 코드 첨부해보기)
이 Converter 내부에서 실제로 사용하는 것이
바로 Jackson ObjectMapper입니다.

🎤
즉, 우리가 겪었던 매핑 오류는
RestTemplate이나 네트워크 문제가 아니라,
ObjectMapper의 역직렬화 단계에서 발생한 문제였습니다.

🎤
그래서 앞에서 반복했던
“서버 재실행 → API 호출 → 확인” 과정은,
결국 이 ObjectMapper 동작 하나를 확인하기 위한 과정이었습니다.

🎤
그렇다면 자연스럽게 이런 질문이 생깁니다.
> “이 ObjectMapper 단계만 따로 테스트할 수는 없을까?”

🎤
이 질문에 대한 답이,
다음 내용에서 다룰 ObjectMapper 단위 테스트입니다.

# 5. 스프링 의존 없이 매핑 검증하기
## 5-1. 접근 방식
🎤
앞에서 살펴본 내용을 바탕으로
테스트의 초점을 바꿔보았습니다.

외부 API 호출 여부,
Spring 애플리케이션 실행 여부는 제외하고

ObjectMapper가 JSON을 DTO로 바꿀 수 있는지만 검증하기로 했습니다.

## 5-2. 어떻게 가능한가?
🎤
RestTemplate을 비롯한 대부분의 HTTP 클라이언트는
응답을 객체로 변환할 때 ObjectMapper를 사용합니다.

따라서,
실제 런타임에서 발생하는 매핑 오류는
ObjectMapper 단위에서도 그대로 재현됩니다.

즉, 서버를 띄우지 않아도 같은 오류를 잡을 수 있습니다.

## 5-3. 테스트 범위 정의
🎤
이 테스트의 전제는 다음과 같습니다.
- 외부 API 응답은 이미 성공했다고 가정
- 네트워크, 컨트롤러, 서비스 로직은 제외
- JSON -> DTO 역직렬화만 검증

테스트 대상이 아래와 같이 좁혀진 것을 확인할 수 있습니다.
```
JSON ──(ObjectMapper)──> DTO
```

## 5-4. 코드 구성 살펴보기
### 1) 디렉토리 구조
```
src/
 ├─ main/
 │   └─ java/
 │       └─ .../client/api/
 │           └─ ApiClientObjectMapperFactory.java # apiClient 전용 ObjectMapper 생성
 └─ test/
     └─ java/
         └─ .../client/api/
	         ├─ dto/
		     │   └─ TodoResponseTest.java # 응답 매핑 테스트
             └─ ApiClientObjectMapperProviderHelper.java  # 테스트 전용(Helper)
             
```
🎤
- main : 운영에서 실제로 사용하는 ObjectMapper 설정
- test : 그 설정을 그대로 가져다 쓰는 테스트 코드
### 2) ObjectMapper 준비
```java
@Component  
@RequiredArgsConstructor  
public class ApiClientObjectMapperFactory {  
  
    public ObjectMapper createApiClientObjectMapper() {  
        final ObjectMapper objectMapper = new ObjectMapper();  
        return objectMapper  
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);  
    }  
}
```
🎤
외부 API의 응답을 객체로 매핑하기 위한 ObjectMapper를 생성합니다.

### 3) DTO 테스트 작성
```java
class TodoResponseTest {

	private ObjectMapper objectMapper;
	
	@BeforeEach
	void init() {
		final ApiClientObjectMapperFactory factory = new ApiClientObjectMapperFactory();
		
		objectMapper = factory.createApiClientObjectMapper();
	}

	@Test  
	@DisplayName("json 문자열을 TodoResponse 객체로 성공적으로 매핑합니다.")  
	void readValue() throws JsonProcessingException {  
	    //given  
	    final String json = """  
	            {
					"userId": 1,
					"id": 1,
					"title": "delectus aut autem",
					"completed": false
				}
				""";  
	  
	    //when  
	    final TodoResponse response = objectMapper.readValue(json, TodoResponse.class);  
	  
	    //then  
	    assertSoftly(it -> {  
	        it.assertThat(response.getUserId()).isEqualTo(1L);  
	        it.assertThat(response.getId()).isEqualTo(1L);
	    it.assertThat(response.getTitle()).isEqualTo("delectus aut autem");  
	    it.assertThat(response.isCompleted()).isEqualTo(false);  
	    });  
	}
}
```
🎤
테스트에서는
운영 코드에 정의된 Factory를 그대로 사용해
운영 환경과 동일한 ObjectMapper를 가져옵니다.

즉, 테스트용 ObjectMapper를 따로 만들지 않고
운영과 동일한 매핑 규칙을 그대로 검증합니다.

이 테스트 하나로
필드 오타, 구조 변경, 타입 불일치를
서버 실행 없이 바로 확인할 수 있습니다.

### 4) 예외 상황도 함께 검증
추가적으로,
```java
@Test  
@DisplayName("존재하지 않는 key의 경우, 예외가 발생합니다.")  
void ignoreKey() {  
    //given  
    final String json = """  
            {
	            "hello": "hi"
			}
			""";  
  
    //when & then  
    assertDoesNotThrow(() -> objectMapper.readValue(json, TodoResponse.class));  
}
```
🎤
외부 API 응답에
예상하지 못한 필드가 추가되더라도
매핑 단계에서 즉시 장애로 이어지지 않음을 확인합니다.


이 덕분에
- 필요한 필드가 정확히 매핑되는지
- 알 수 없는 필드가 추가돼도 문제가 발생하지 않는지
  를 검증할 수 있었습니다.

## 5-5. 테스트의 목적
🎤
외부 API 응답이
우리 DTO로 안전하게 들어오는지
서버 실행 없이 확인하는 것입니다.

이를 통해
가장 자주 발생하는 매핑 오류를
개발 단계에서 바로 발견할 수 있습니다.
# 6. 결론
🎤
오늘 테스트 방식을 통해서 우리는 이와 같은 결론을 알 수 있게 되었습니다.

외부 API 연동 과정에서
매핑 오류를 확인하기 위해 서버까지 띄울 필요는 없습니다.

응답 매핑은
대부분 ObjectMapper 역직렬화 단계에서 결정됩니다.

따라서, 매핑 검증은 ObjectMapper 단위 테스트로 빠르게
실제 호출 검증은 통합 테스트로 최소화할 수 있습니다.

이렇게 역할을 나누면,
테스트 속도는 빨라지고
불필요한 반복 작업을 줄이며
매핑 오류를 훨씬 이른 시점에 발견할 수 있습니다.

---

# 7. Q&A

# 8. 마무리