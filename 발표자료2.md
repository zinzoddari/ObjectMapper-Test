# 1. 발표자 소개
...

# 2. 왜 발표하게 되었나요?
Spring 환경에서 외부 API를 연동할 때,
여러분은 보통 어떤 방식으로 테스트하고 계신가요?

저는 외부 API를 연동하면서,
테스트해야 할 요소가 생각보다 많다는 걸 자주 느꼈습니다.
네트워크, 인증, 응답 구조 등 확인할 것이 많았고,
그중에서도 특히 자주 확인하게 된 것은
응답 값이 DTO로 잘 매핑되는지 여부였습니다.

그런데 이 매핑을 확인하는 과정에서
늘 같은 작업을 반복하고 있었습니다.

DTO를 조금 수정하고,
스프링 애플리케이션을 다시 실행한 뒤,
외부 API를 호출하는 내부 API를 만들어 직접 요청을 보내보는 방식이었습니다.

처음에는 당연하다고 생각했지만,
이 작업이 반복될수록 점점 비효율적으로 느껴지기 시작했습니다.

“지금 내가 확인하고 싶은 건
정말 외부 API 호출이 잘 되는지일까?
아니면 응답 JSON이 DTO로 제대로 매핑되는지일까?”

이 질문을 계기로,
응답 값의 매핑에 대한 확인을 더 단순하게 가져갈 수는 없을지 고민하게 되었습니다.

먼저 기존의 방식이 어땠는지부터 알아보겠습니다.

# 3. 기존 방식
## 베이스코드
기존 방식을 설명하기 앞서, 오늘 우리의 기반 코드를 먼저 설명하겠습니다.
```
JsonConfig
  └─ new ObjectMapper()
       │
       ▼
DummyObjectMapperProvider
  └─ getDummyObjectMapper()
       │
       ▼
DummyClientProvider
  ├─ ObjectMapper로 MessageConverter 생성
  ├─ RestTemplate 생성
  └─ DummyClient 생성
       │
       ▼
DummyClient
  └─ RestTemplate.exchange()
```

### JsonConfig
```java
@Configuration  
class JsonConfig {  
  
    @Bean  
    public ObjectMapper objectMapperConfig() {  
        ObjectMapper objectMapper = new ObjectMapper();  
  
        objectMapper.registerModule(new JavaTimeModule());  
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);  
  
        return objectMapper;  
    }  
}
```

### DummyObjectMapperProvider
```java
@Configuration  
@RequiredArgsConstructor  
class DummyClientProvider {  
  
    private final DummyObjectMapperProvider objectMapperProvider;  
  
    @Bean  
    public DummyClient dummyClient(@Value("${api.dummy.base-uri}") final String baseUri, final RestTemplateBuilder builder) {  
        final ObjectMapper dummyObjectMapper = objectMapperProvider.getDummyObjectMapper();  
  
       final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(dummyObjectMapper);  
  
        final RestTemplate restTemplate = builder.rootUri(baseUri)  
                .additionalMessageConverters(converter)  
                .build();  
  
        return new DummyClient(restTemplate);  
    }  
}
```

### DummyClient
```java
@Slf4j  
@RequiredArgsConstructor  
public class DummyClient {  
  
    private final RestTemplate restTemplate;  
  
    public <R> R get(final String uri, final ParameterizedTypeReference<R> reference) {  
        log.debug("request: {}, {}", uri);  
  
        RequestEntity<Void> request = RequestEntity  
                .get(uri)  
                .accept(MediaType.APPLICATION_JSON)  
                .build();  
  
        ResponseEntity<R> response = restTemplate.exchange(request, reference);  
  
        log.debug("response: {}, {}", uri, response);  
  
        if (response.getStatusCode().isError()) {  
            throw new RuntimeException();  
        }  
  
        if (ObjectUtils.isEmpty(response.getBody())) {  
            return null;  
        }  
  
        return response.getBody();  
    }  
}
```
이러한 코드로 외부 API를 호출한다고 가정합니다.

## 필드 매핑이 되지 않을 때 (이게 맞나)
외부 API는 성공 시 아래와 같은 JSON 응답을 내려준다고 가정합니다.
![Pasted image 20251215005913.png](image%2FPasted%20image%2020251215005913.png)
```json
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
```

해당 응답 값을 매핑하기 위한 객체로 TodoResponse가 존재합니다.
```java
@Getter  
@NoArgsConstructor(access = AccessLevel.PRIVATE)  
public class TodoResponse {  
  
    private Long userId;  
  
    private Long id;  
  
    private String tilte;
  
    private Boolean completed;  
}
```

응답 매핑이 정상 동작하는지 확인하기 위해,
외부 API 호출을 트리거하는 내부 API를 별도로 만들었습니다.
![Pasted image 20251215010321.png](image%2FPasted%20image%2020251215010321.png)

![Pasted image 20251214161257.png](image%2FPasted%20image%2020251214161257.png)

이제 작성한 로직을 바탕으로 외부 API 응답 값이 정상적으로 객체에 매핑되는지 테스트하기 위해, Spring Application을 실행 시킵니다.

서버가 정상적으로 켜진것이 확인이 되면, 만든 API를 호출합니다.

![Pasted image 20251214161438.png](image%2FPasted%20image%2020251214161438.png)

하지만, 응답 Status가 500으로 떨어진 것을 확인할 수 있었습니다.

```
com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field "title" (class jackson.study.config.client.dto.TodoResponse), not marked as ignorable (4 known properties: "tilte", "id", "userId", "completed"])
 at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 4, column: 13] (through reference chain: jackson.study.config.client.dto.TodoResponse["title"])
```

서버 오류를 찾아보니
- Jackson(ObjectMapper)이 JSON을 TodoResponse로 역직렬화하는 과정에서
- JSON에는 title 필드가 존재하는데,
- TodoResponse 클래스에는 title 필드가 없어서
- 매핑에 실패했음을 알려주고 있습니다.

이유를 찾아보니, title이 아닌 tilte로 필드가 제대로 작성되지 않음을 확인할 수 있었습니다.

```java
public class TodoResponse {  
	...
    private String tilte; // <- 오타
```

그리하여, 필드명을 수정해주고, 다시 스프링 애플리케이션을 재실행하였습니다.
![화면 기록 2025-12-14 17.18.32.gif](image%2F%ED%99%94%EB%A9%B4%20%EA%B8%B0%EB%A1%9D%202025-12-14%2017.18.32.gif)
![화면 기록 2025-12-14 17.21.23.gif](image%2F%ED%99%94%EB%A9%B4%20%EA%B8%B0%EB%A1%9D%202025-12-14%2017.21.23.gif)

```
[DTO 필드 수정]
        ↓
[Spring 애플리케이션 재실행]
        ↓
[API 호출]
        ↓
[응답 매핑 결과 확인]
        ↺ (실패 시 다시 반복)
```

이렇게 외부 API 응답이 객체로 잘 매핑되는지 확인하기 위해,
매번 같은 과정을 반복하고 있었습니다.

그러다 문득,
매핑만 따로 검증할 수는 없을지 고민하게 되었습니다.

# 원인 해부
RestTemplate 내부에 ObjectMapper가 MessageConverter로 등록
외로 다른 HTTP 클라이언트 대부분도 ObjectMapper로 처리 함

![Pasted image 20251214173317.png](image%2FPasted%20image%2020251214173317.png)

결국 ObjectMapper로 인해 JSON이 Object로 역직렬화 되는 것을 확인할 수 있음

# 사전에 막는 방법
API 응답 자체는 성공 했음을 가정하고 테스트를 함

HTTP Client가 사용하는 ObjectMapper를 DI 받고, 응답으로 내려주는 JSON 값을 가지고 역직렬화 테스트만을 함
## DI
```java
@Component  
@RequiredArgsConstructor  
class DummyObjectMapperProvider {  
  
    private final ObjectMapper objectMapper;  
  
    public ObjectMapper getDummyObjectMapper() {  
        return objectMapper.copy()  
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);  
    }  
}
```

```java
@Configuration  
@RequiredArgsConstructor  
class DummyClientProvider {  
  
    private final DummyObjectMapperProvider objectMapperProvider;  
  
    @Bean  
    public DummyClient dummyClient(@Value("${api.dummy.base-uri}") final String baseUri, final RestTemplateBuilder builder) {  
        final ObjectMapper dummyObjectMapper = objectMapperProvider.getDummyObjectMapper();  
  
       final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(dummyObjectMapper);  
  
        final RestTemplate restTemplate = builder.rootUri(baseUri)  
                .additionalMessageConverters(converter)  
                .build();  
  
        return new DummyClient(restTemplate);  
    }  
}
```

```java
public class JsonConfigHelper {  
  
    private JsonConfig jsonConfig = new JsonConfig();  
  
    public ObjectMapper getTestObjectMapper() {  
        return jsonConfig.objectMapperConfig();  
    }  
}
```

```java
public class DummyObjectMapperProviderHelper {

    private final DummyObjectMapperProvider objectMapperProvider;  
  
    public DummyObjectMapperProviderHelper() {  
        JsonConfigHelper jsonConfigHelper = new JsonConfigHelper();  
        this.objectMapperProvider = new DummyObjectMapperProvider(jsonConfigHelper.getTestObjectMapper());  
    }  
  
    public ObjectMapper getDummyObjetMapper() {  
        return objectMapperProvider.getDummyObjectMapper();  
    }  
}
```

```java
class TodoResponseTest {  
  
    private final ObjectMapper objectMapper;  
  
    private TodoResponseTest() {  
        final DummyObjectMapperProviderHelper helper = new DummyObjectMapperProviderHelper();  
  
        this.objectMapper = helper.getDummyObjetMapper();  
    }
}
```

```java
class TodoResponseTest {

	private final ObjectMapper objectMapper;
	
	...

	@Test  
	@DisplayName("json 문자열을 TodoResponse 객체로 성공적으로 매핑합니다.")  
	void readValue() throws JsonProcessingException {  
	    //given  
	    final String json = """  
	            {
					"userId": 1,
					"id": 1,
					"title": "delectus aut autem",
					"completed": false
				}
				""";  
	  
	    //when  
	    final TodoResponse response = objectMapper.readValue(json, TodoResponse.class);  
	  
	    //then  
	    assertSoftly(it -> {  
	        it.assertThat(response.getUserId()).isEqualTo(1L);  
	        it.assertThat(response.getId()).isEqualTo(1L);
	    it.assertThat(response.getTitle()).isEqualTo("delectus aut autem");  
	    it.assertThat(response.isCompleted()).isEqualTo(false);  
	    });  
	}
}
```

# 추가적으로
존재하지 않는 key가 들어왔을 때도 역직렬화가 잘 되는 것을 확인 할 수 있다.
```java
@Test  
@DisplayName("존재하지 않는 key의 경우, 예외가 발생합니다.")  
void ignoreKey() {  
    //given  
    final String json = """  
            {
	            "hello": "hi"
			}
			""";  
  
    //when & then  
    assertThatThrownBy(() -> objectMapper.readValue(json, PostsResponse.class))  
            .isInstanceOf(UnrecognizedPropertyException.class);  
}
```

이런 방식으로 했을 때의 장점, 단점

그래서 나는 실무에서 할 때, API 네트워크 테스트는 최소한으로 하고,
이런 역직렬화 테스트를 더 많이 하는 듯

# 결론
이걸 통해서 어떠한걸 얻을 수 있을까?
